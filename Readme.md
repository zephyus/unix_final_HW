
本作業的核心目標是使用 awk 語言，完成 msed 前處理器的所有翻譯邏輯。您需要填寫提供的msed_new範本檔案中的空白部分，將 msed 的擴充語法轉換為標準 sed 指令

檔案說明 (Provided Files)
msed_new：這是您需要編輯與繳交的主要檔案。請在此範本的基礎上，填寫所有 _________ 部分
msed_old_correctbyteacher：一個功能完整但使用純 sed 技巧實作的參考版本。此檔案是您的功能規格書 (Functional Specification)。當您不確定某個 msed 功能應如何運作時，請研究此檔案中對應的實作，它定義了正確的行為。


循序漸進: 強烈建議您不要試圖一次完成所有內容。依照 msed.csh 的執行順序，逐一完成每個 _________。
參考規格: 在實作每個功能前，務必研究 msed_sed_solution.csh 中對應的區塊，以完全理解其輸入與預期輸出。
獨立測試: 針對您完成的每一小部分功能，編寫獨立的測試案例來驗證其正確性。例如，要測試參數替換，您可以建立一個包含 $2 的簡單檔案，並手動執行您的 awk 命令，檢查輸出是否如預期。

所有您在實作時需要遵守的規格、功能要求、以及限制條列如下。




# msed 前處理器 — AWK 版本專案說明書 （Updated）

> **目標**
> 使用 **AWK** 將擴充語法的 `msed` 腳本轉譯成可直接被 **標準 `sed`** 執行的腳本，功能必須覆蓋參數化、負數行號與新增命令等全部特性。

---

## 一、專案檔案

| 檔名                          | 角色   | 說明                                          |
| --------------------------- | ---- | ------------------------------------------- |
| **`msed_new`**              | ★ 主角 | 你要編輯並繳交的 csh + awk 腳本。所有 `_________` 皆需補完。  |
| `msed_old_correctbyteacher` | 規格書  | 老師提供的 **純 `sed` 實作**，行為即為「正確結果」。遇到疑惑請先對照此檔。 |

---

## 二、開發建議流程

1. **循序漸進**：依 `msed_new` 執行順序，**一次完成一段空白** 並立即測試。
2. **比對規格**：實作前先在 `msed_old_correctbyteacher` 找到對應區塊，弄懂「輸入 ➜ 期望輸出」。
3. **獨立測試**：為每個功能寫極小測例，例如專門確認「`$2` 參數替換」「`Z` 命令轉譯」等。

---

## 三、csh 腳本層（`msed_new` 前半）的 AWK 任務

| 行次     | 區塊功能           | 詳細規定                                                                                                     |                         |        |
| ------ | -------------- | -------------------------------------------------------------------------------------------------------- | ----------------------- | ------ |
| **17** | **參數化替換**      | 對 `t5` 內容將 `$2 $3 …` 依序換成實際參數。<br>匹配式須避免把 `$1` 誤抓成 `$11`：建議 \`\${idx}(\[^0-9]                            | \$)`或`\\\$"idx"(\[^0-9] | \$)\`。 |
| **32** | **分號換行**       | 1. 把 `\\` → `\a`、`\;` → `\f`（暫存）。<br>2. 其餘 `;` → `\n;`。<br>3. 還原 `\a → \\`、`\f → \;`。<br>4. 移掉第 1 行前導空格。 |                         |        |
| **35** | **抽出主體 AWK**   | 從 `exit 0` 之後全部印出為 `t7`。                                                                                 |                         |        |
| **54** | **抓 `$-#` 數字** | 若行內有 `\$-\v([0-9]+)`（`\v` 係前步驟加的標記），輸出 `#`；否則輸出空字串。                                                      |                         |        |
| **63** | **最終替換**       | 1. 把 `$-\v#` 換成實際行號 `$z`。<br>2. 針對 `F` 產生的 branch label 必須附加計數器 `$cnt`，確保全檔唯一。                           |                         |        |

---

## 四、主體 AWK 腳本（`exit 0` 之後）

1. ### 行合併

   *重新組回誤被 `\n;` 拆開的*

   * `s / y / \x..\x / /.../` 指令。
   * 地址範圍 `addr1,addr2` 內若含 `/.../` 或 `\x..\x` 亦需合併。
   * **簡化**：`[;]` 內的分號可不處理。

2. ### `{` 區塊分行

   * 非 `s` 指令的 `{`：把 `{` 後面的東西移到下一行。
   * 範例：`/x/{p` ➜ `/x/{` + `p`

3. ### 新命令轉譯

   | msed 命令   | 轉譯為 sed                                | 額外說明                                            |
   | --------- | -------------------------------------- | ----------------------------------------------- |
   | `Z`       | `s/.*//`                               | 範圍內清空 pattern space                             |
   | `W`       | `s/.*//; g; s/.*//; G`                 | 先清 pattern，再把 hold 倒回 pattern 清光，最後把空 hold 附回 ✔ |
   | `D`       | `h; d` **→** 更符合老師解釋：`x; s/.*//; x; d` | 將 pattern 送入 hold 再刪除                           |
   | `C`       | `H; x; s/\r\v$//; x`                   | 把 pattern 附加到 hold；同時移除旗標標記                     |
   | `F label` | *見「旗標判斷」*                              | 若 hold **含** `\r\v` ➜ 跳 `label`                 |
   | `f label` | *見「旗標判斷」*                              | 若 hold **不含** `\r\v` ➜ 跳 `label`                |

4. ### 旗標判斷／保護（**重點**）

   任何 **`s`** 會破壞 t-flag。對所有可能改變旗標狀態的區段（含 `s`, `F`, `f`…）必須 **包進「守護區塊」**：

   ```sed
   # ──(a) 操作前先備份旗標──
   T flagL_pre_N; x; s/$/\r\v/; x; :flagL_pre_N

   <潛在破壞旗標的指令>

   # ──(b) 操作後恢復旗標──
   T flagL_post_N; :flagL_post_N; x; s/\r\v$//; x
   ```

   * `N` 為遞增計數器，確保 `flagL_pre_N` / `flagL_post_N` 全檔唯一。
   * **`F` / `f` 轉譯**（示例）：

     ```sed
     # F label   →  若 hold 有 \r\v 就跳
     x; /\r\v$/b _FJUMP_N; x
     ...
     :_FJUMP_N

     # f label   →  若 hold 沒 \r\v 就跳
     x; /\r\v$/!b _fJUMP_N; x
     ...
     :_fJUMP_N
     ```

5. ### `$-#` 標記

   在主體 AWK 中先把 `$-23` → `$-\v23`，留待 csh 第 63 行換算。

6. ### 反斜線標記復原

   結尾把 `\a → \\`、`\f → \;` 還原。

---

## 五、不需支援的語法（老師明確放寬）

1. **地址範圍**

   * `$-x,$-y` 與 `x,$-y{` → 不測。
2. **巢狀謂詞**

   * `2,4{3=}` 這種 `predication{more_predication}` 不必處理。
3. **Basic RE 反向參照語法**

   * 不用支援 `\(.\)\1`，在 AWK 皆應用 ERE `(.)\1` 或其他邏輯重寫。

---

## 六、測試建議

```bash
# 參數化
echo 's/$2/world/' > ex.msed
echo foo | ./msed_new ex.msed hello

# Z / W / D / C 功能
printf 'a\nb\n' | ./msed_new 'Z'
printf 'a\nb\n' | ./msed_new 'W'
printf 'a\nb\n' | ./msed_new 'D'
printf 'a\nb\n' | ./msed_new 'C'

# 旗標判斷
printf 'a\n' | ./msed_new 's/a/b/;F skip;='
printf 'a\n' | ./msed_new 's/a/a/;f there;='
```

建議 **單元測**➜**整合測**：先確定每塊 AWK 填空正確，再串全流程驗證。





本作業的核心目標是使用 awk 語言，完成 msed 前處理器的所有翻譯邏輯。您需要填寫提供的msed_new範本檔案中的空白部分，將 msed 的擴充語法轉換為標準 sed 指令

檔案說明 (Provided Files)
msed_new：這是您需要編輯與繳交的主要檔案。請在此範本的基礎上，填寫所有 _________ 部分
msed_old_correctbyteacher：一個功能完整但使用純 sed 技巧實作的參考版本。此檔案是您的功能規格書 (Functional Specification)。當您不確定某個 msed 功能應如何運作時，請研究此檔案中對應的實作，它定義了正確的行為。


循序漸進: 強烈建議您不要試圖一次完成所有內容。依照 msed.csh 的執行順序，逐一完成每個 _________。
參考規格: 在實作每個功能前，務必研究 msed_sed_solution.csh 中對應的區塊，以完全理解其輸入與預期輸出。
獨立測試: 針對您完成的每一小部分功能，編寫獨立的測試案例來驗證其正確性。例如，要測試參數替換，您可以建立一個包含 $2 的簡單檔案，並手動執行您的 awk 命令，檢查輸出是否如預期。

所有您在實作時需要遵守的規格、功能要求、以及限制條列如下。

### **核心目標**



您的核心任務是使用 **`awk`** 語言，完整重現一個 `msed` 前處理器的功能。這個前處理器會讀取一個使用擴充語法（參數化、負數行號、新命令）的 `msed` 腳本，並將其翻譯成一個功能完全相同、可以被標準 `sed` 執行的腳本。



---



### **C Shell 腳本中的 `awk` 任務**



您需要在 `csh` 腳本的迴圈與處理流程中，完成以下標示為 `_________` 的 `awk` 指令：



1.  **`foreach` 迴圈中的 `awk` (line 17):**

    * **功能：** 參數化替換。

    * **邏輯：** 讀取 `t5` 檔案的內容（初始為 `$1`），尋找腳本中出現的參數佔位符（如 `$2`, `$3`...），並將其替換為對應的實際參數值。每一次迴圈處理一個參數。

    * **範例：** 若 `t5` 內容為 `s/$2/hello/g`，且 `argv[2]` 是 `world`，則 `awk` 需輸出 `s/world/hello/g`。



2.  **分號轉譯的 `awk` (line 32):**

    * **功能：** 將大部分的分號 `;` 轉換為換行符，以利後續逐行處理 `sed` 指令。

    * **邏輯：**

        * 將 `\;` (被跳脫的分號) 暫時替換為一個不會出現的特殊字元。

        * 將 `\\` (被跳脫的反斜線) 暫時替換為另一個特殊字元（如 `\a`），以防它跳脫了後面的分號。

        * 將剩餘的所有 `;` 替換為 `\n;`。

        * 還原之前替換的 `\;` 和 `\\`。

        * 移除檔案開頭由 `echo \ $1` 加入的多餘空格。



3.  **建立 `awk` 程式的 `awk` (line 35):**

    * **功能：** 從 `msed` 腳本自身的 `exit 0` 之後提取主體 `awk` 程式碼。

    * **邏輯：** 尋找 `exit 0` 這一行，並印出其後的所有內容。這會變成 `t7` 這個 `awk` 程式檔。



4.  **提取負數行號的 `awk` (line 54):**

    * **功能：** 從一行 `sed` 指令中，找出 `$-#` 語法中的數字 `#`。

    * **邏輯：** 使用 `awk` 的正則表達式匹配 `$-` 後面的數字部分，並將其印出。如果沒有匹配，則不輸出任何東西。



5.  **最終清理與替換的 `awk` (line 63):**

    * **功能：** 進行最後的轉換。

    * **邏輯：**

        * 將 `$-#` 語法替換為 `csh` 腳本中計算出的實際行號 (`$z`)。

        * 對於 `F` 命令，其產生的 `sed` 分支標籤（branch label）必須是唯一的。您需要將 `csh` 迴圈中的計數器 `$cnt` 的值附加到標籤名稱後，以確保唯一性。



---



### **主體 `awk` 腳本任務 (從 `exit 0` 之後的程式碼)**



這部分是整個專案的核心，也就是 `t7` 的內容。它負責將 `msed` 的擴充語法轉換為標準 `sed` 指令。



1.  **行合併 (Line Merging):**

    * **問題背景：** `csh` 腳本的第 32 行會將大部分分號轉為換行，但 `s`, `y`, `\` 和 `/.../` 命令自身可能合法地包含分號，這會導致一個完整的指令被錯誤地拆成多行。

    * **您的任務：** 撰寫 `awk` 邏輯來識別這些被錯誤拆分的行，並將它們重新合併為一行。

    * **需處理的案例：**

        * `s/;/;/` 或 `s;a;b;`

        * `y;a;,;b;`

        * `\c...c` (其中 `c` 是分隔符)

        * `/.../` 或 `\c...\c`

        * 地址範圍中的 `/.../`，例如 `/,/a;/p`

    * **簡化：** 您不需要處理正則表達式中用方括號 `[]` 包含的分號，如 `s/[;]/foo/`。



2.  **`{` 大括號處理:**

    * **功能：** 將 `sed` 的指令區塊 `{...}` 分離。

    * **邏輯：** 如果一行包含一個非 `s` 命令分隔符的 `{`，則將 `{` 之後的指令移到下一行。

    * **範例：**

        * `/x/{p`  應變為兩行：`/x/{` 和 `p`。

        * `{=`  應變為兩行：`{` 和 `=`。

        * `s{x{y{g` 則**不變**，因為 `{` 是 `s` 命令的分隔符。



3.  **新命令轉譯 (`Z, W, D, C, f, F`):**

    * **`Z` (Zap):** 刪除模式空間內容 (`s/.*//`)。

    * **`W` (Wipe):** 清空模式空間與保留空間 (`s/.*//;g;s/.*//;G`)。

    * **`D` (Delete and Hold):** 將模式空間內容移至保留空間後刪除 (`h;d`)。

    * **`C` (Copy):** 將模式空間內容附加到保留空間 (`H`)。

    * **`f` (flag-based branch):** 如果 t-flag **已設定**，則跳轉到標籤。這通常翻譯為 `t label`。

    * **`F` (NOT flag-based branch):** 如果 t-flag **未設定**，則跳轉到標籤。這通常翻譯為 `T label`。



4.  **旗標處理的正確方法 (老師的關鍵提醒):**

    * **核心概念：** 任何 `s` 命令都可能重設 t-flag。為了在複雜的 `msed` 命令序列中保持旗標狀態，您必須使用保留空間 (hold space) 來「備份」旗標的狀態。

    * **您的 `awk` 腳本的任務：** 當您轉譯一個需要保護旗標狀態的命令時 (例如 `f` 或 `F`)，您**不是**在 `awk` 中判斷旗標，而是要 `print` 出一系列 `sed` 指令，讓 `sed` 在執行階段自行處理旗標。

    * **生成的 `sed` 程式碼序列：**

        * **操作前保存旗標：** 在可能破壞旗標的 `sed` 指令**之前**，您的 `awk` 腳本需要印出：

            ```sed

            T flagL_pre_UNIQUE; x; s/$/\r\v/; x; :flagL_pre_UNIQUE

            ```

            * **`T flagL_pre_UNIQUE`**: 如果 t-flag **未**設定，就跳過保存操作。

            * **`x; s/$/\r\v/; x;`**: 如果 t-flag **已**設定，則在保留空間的末尾附加一個特殊標記 (`\r\v`)。

            * **`:flagL_pre_UNIQUE`**: 標籤。

        * **操作後恢復旗標：** 在可能破壞旗標的 `sed` 指令**之後**，您的 `awk` 腳本需要印出：

            ```sed

            T flagL_post_UNIQUE; :flagL_post_UNIQUE; x; s/\r\v$//; x

            ```

            * **`T flagL_post_UNIQUE; :flagL_post_UNIQUE;`**: 這是一個重設 (清除) t-flag 的技巧。

            * **`x; s/\r\v$//; x`**: 無論 t-flag 為何，都嘗試從保留空間中移除標記 `\r\v`。這會恢復保留空間的原始狀態，並間接恢復了 t-flag 的邏輯狀態。

    * **注意：** 您必須確保 `flagL_pre_UNIQUE` 和 `flagL_post_UNIQUE` 在整個生成的 `sed` 腳本中是唯一的，通常可以透過加入計數器來實現。



5.  **負數行號標記:**

    * **功能：** 標記出 `$-#` 語法，以便 `csh` 腳本的後續步驟能找到並替換它。

    * **邏輯：** 使用 `awk` 將 `$-#` 替換為 `\v#` 這樣的形式。使用 `\v` (垂直定位字元) 是因為它極少出現在一般文本中。



6.  **反斜線清理:**

    * **功能：** 處理 `\\` 和 `\;` 留下的臨時標記。

    * **邏輯：** 將之前在 `csh` 腳本中用於保護 `\\` 的 `\a` 轉換回 `\`。



---



### **老師的關鍵提醒與限制 (Unsupported Syntax)**



以下是老師明確指出**不需要**您支援的複雜語法，這會簡化您的實作：



1.  **`awk` 的正則表達式：**

    * `awk` 使用擴展正則表達式 (ERE)。用於分組的是 `()` 而不是 `\(\)`。老師的提醒 "You cannot use the `\(.\)\1` syntax" 指的是在正則表達式的**匹配部分**要用 `(.)` 而不是 `\(.\)`。



2.  **不支援的地址範圍：**

    * `$-x, $-y` (範圍的起點和終點都是負數行號)。

    * `x, $-y {` (範圍以負數行號結尾，且後面直接跟大括號 `{`)。處理此情況可能有額外加分，但**不是必要要求**。



3.  **不支援的巢狀謂詞 (Nested Predication):**

    * 您**不需要**支援 `predication{more_predication}` 這種語法，例如 `2,4{3=}` (對 2-4 行中的第 3 行執行 `=` 命令)。您只需處理 `2,4{=}` 這種簡單形式。

嚴謹檢查 當前是否所有功能都符合要求?使用多種簡單case大量分段測試



我可以直接這樣prompt來讓專家審視我完成的實作嗎?這樣是否涵蓋所有老師要求?
